package com.example.inventory.service;

import com.example.inventory.model.Aisle;
import com.example.inventory.model.Box;
import com.example.inventory.model.Item;
import com.example.inventory.model.ItemStatus;
import com.example.inventory.model.Location;
import com.example.inventory.model.LocationCapacityType;
import com.example.inventory.model.QcStatus;
import com.example.inventory.model.StorageArea;
import com.example.inventory.model.StorageAreaType;
import com.example.inventory.repository.AisleRepository;
import com.example.inventory.repository.BoxRepository;
import com.example.inventory.repository.ItemRepository;
import com.example.inventory.repository.LocationRepository;
import com.example.inventory.repository.StorageAreaRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Implementation of WarehouseService with ID generation logic for hierarchical
 * storage locations in warehouse:
 * - StorageArea: auto-increment ID (type required: INWARD/OUTWARD/STORAGE/PIGEON_HOLE)
 * - Aisle: S{areaId}-A{N} where N = count in area + 1
 * - Location: {aisleId}-L{M} where M = count in aisle + 1 (type: SINGLE/MULTI)
 * - Box: auto ID, type=StorageAreaType, nullable Location ref (type must match on assignment)
 */
@Service
public class WarehouseServiceImpl implements WarehouseService {

    private final StorageAreaRepository storageAreaRepository;
    private final AisleRepository aisleRepository;
    private final LocationRepository locationRepository;
    private final BoxRepository boxRepository;
    private final ItemRepository itemRepository;

    public WarehouseServiceImpl(StorageAreaRepository storageAreaRepository,
                                AisleRepository aisleRepository,
                                LocationRepository locationRepository,
                                BoxRepository boxRepository,
                                ItemRepository itemRepository) {
        this.storageAreaRepository = storageAreaRepository;
        this.aisleRepository = aisleRepository;
        this.locationRepository = locationRepository;
        this.boxRepository = boxRepository;
        this.itemRepository = itemRepository;
    }

    @Override
    @Transactional
    public StorageArea createStorageArea(String description, StorageAreaType type) {
        if (type == null) {
            throw new IllegalArgumentException("StorageArea type is required");
        }
        // ID auto-generated by JPA
        StorageArea area = new StorageArea(description, type);
        return storageAreaRepository.save(area);
    }

    @Override
    @Transactional
    public Aisle createAisle(Long storageAreaId) {
        // Validate storage area exists
        if (!storageAreaRepository.existsById(storageAreaId)) {
            throw new IllegalArgumentException("Storage area not found: " + storageAreaId);
        }
        // Determine next aisle number in this storage area
        long aisleNum = aisleRepository.countByStorageAreaId(storageAreaId) + 1;
        String aisleId = "S" + storageAreaId + "-A" + aisleNum;
        // Check uniqueness (though sequential should ensure)
        if (aisleRepository.existsById(aisleId)) {
            throw new IllegalArgumentException("Aisle already exists: " + aisleId);
        }
        Aisle aisle = new Aisle(aisleId, storageAreaId);
        return aisleRepository.save(aisle);
    }

    @Override
    @Transactional
    public Location createLocation(Long storageAreaId, String aisleId, LocationCapacityType type) {
        if (type == null) {
            throw new IllegalArgumentException("Location type is required");
        }
        // Validate storage area and aisle exist
        if (!storageAreaRepository.existsById(storageAreaId)) {
            throw new IllegalArgumentException("Storage area not found: " + storageAreaId);
        }
        if (!aisleRepository.existsById(aisleId)) {
            throw new IllegalArgumentException("Aisle not found: " + aisleId);
        }
        // Optionally: validate aisle belongs to area
        // Aisle aisle = aisleRepository.findById(aisleId).get();
        // if (!aisle.getStorageAreaId().equals(storageAreaId)) { ... }
        // Determine next location number in this aisle
        long locNum = locationRepository.countByAisleId(aisleId) + 1;
        String locationId = aisleId + "-L" + locNum;
        // Check uniqueness
        if (locationRepository.existsById(locationId)) {
            throw new IllegalArgumentException("Location already exists: " + locationId);
        }
        Location location = new Location(locationId, storageAreaId, aisleId, type);
        return locationRepository.save(location);
    }

    @Override
    @Transactional
    public Box createBox(StorageAreaType type, QcStatus qcStatus, Long orderId) {
        if (type == null) {
            throw new IllegalArgumentException("Box type is required");
        }
        if (qcStatus == null) {
            throw new IllegalArgumentException("Box QC status is required");
        }
        if (type == StorageAreaType.INWARD && (orderId == null || orderId <= 0)) {
            throw new IllegalArgumentException("orderId required for INWARD box type");
        }
        // ID auto-generated; location/items nullable; orderId set for INWARD
        // (full OMS order validation in WMS layer)
        Box box = new Box(type, qcStatus);
        if (orderId != null) {
            box.setOrderId(orderId);
        }
        return boxRepository.save(box);
    }

    @Override
    @Transactional
    public Box updateBoxLocation(Long boxId, String locationId) {
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new IllegalArgumentException("Box not found: " + boxId));

        if (locationId == null || locationId.isEmpty()) {
            // Allow unassign
            box.setLocation(null);
            return boxRepository.save(box);
        }

        // Validate location exists
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found: " + locationId));

        // Enforce StorageArea type via area for new location
        // (Box.type remains fixed at creation for identity; status is dynamic for current state)
        // Removed strict Box.type == area.type mismatch (was blocking INWARD Box -> STORAGE Location)
        // State machine below allows valid moves (e.g., INWARD->STORAGE)
        Long areaId = location.getStorageAreaId();
        StorageArea area = storageAreaRepository.findById(areaId)
                .orElseThrow(() -> new IllegalArgumentException("Storage area not found for location"));

        // Guardrail for inventory accuracy: Box StorageAreaType movement state machine
        // Allowed: INWARD -> STORAGE, STORAGE -> STORAGE/OUTWARD, OUTWARD -> none (terminal)
        // PIGEON_HOLE treated as STORAGE-like; prevents invalid moves (e.g., OUTWARD back)
        // Enables INWARD Box to STORAGE Location (as required)
        StorageAreaType newType = area.getType();
        StorageAreaType currentType = (box.getLocation() != null)
            ? getAreaTypeForLocation(box.getLocation())
            : null;  // initial assignment allowed
        if (!isValidAreaTypeTransition(currentType, newType)) {
            throw new IllegalArgumentException(
                String.format("Invalid state machine transition for Box %s: %s -> %s (allowed: INWARD->STORAGE, STORAGE<->STORAGE/OUTWARD, OUTWARD terminal)",
                    boxId, currentType, newType));
        }

        // Item/Box status state machine guardrail:
        // - Box.status updated to Location's StorageArea.type (dynamic; e.g., INWARD Box -> STORAGE)
        // - When Box moved to STORAGE Location: Items -> LIVE (e.g., received inward -> live storage)
        // - Ties to CREATED/INWARD prior states; ensures inventory accuracy
        box.setStatus(newType);  // sync Box status to new area type (allows INWARD->STORAGE)
        if (newType == StorageAreaType.STORAGE) {
            for (Item item : box.getItems()) {
                item.setItemStatus(ItemStatus.LIVE);
            }
        }

        box.setLocation(location);
        return boxRepository.save(box);  // cascades Item/Box status updates
    }

    /**
     * Helper: Get StorageAreaType for a Location (via parent area) for state machine checks.
     */
    private StorageAreaType getAreaTypeForLocation(Location location) {
        Long areaId = location.getStorageAreaId();
        return storageAreaRepository.findById(areaId)
                .orElseThrow(() -> new IllegalArgumentException("Storage area not found for location"))
                .getType();
    }

    /**
     * State machine guardrail for Box StorageAreaType movements to ensure inventory accuracy.
     * - INWARD can only go to STORAGE (e.g., receiving to storage)
     * - STORAGE can stay in STORAGE or move to OUTWARD (e.g., picking/shipping)
     * - OUTWARD is terminal (no further moves)
     * - PIGEON_HOLE treated as STORAGE (specialized static)
     * Returns true for initial (null current) if type matches location.
     */
    private boolean isValidAreaTypeTransition(StorageAreaType current, StorageAreaType next) {
        if (current == null) {
            return true;  // initial assignment (type already matched above)
        }
        return switch (current) {
            case INWARD -> next == StorageAreaType.STORAGE;
            case STORAGE, PIGEON_HOLE -> next == StorageAreaType.STORAGE || next == StorageAreaType.OUTWARD;
            case OUTWARD -> false;  // terminal, no moves
            default -> false;
        };
    }

    @Override
    @Transactional
    public Item createItem(String productId, QcStatus qcStatus) {
        if (qcStatus == null) {
            throw new IllegalArgumentException("Item QC status is required");
        }
        // Product validation moved to WMS layer to call OMS API (OMS as source of truth)
        // Library keeps simple create for Item (defaults to CREATED status).
        Item item = new Item(productId, qcStatus);
        return itemRepository.save(item);
    }

    @Override
    @Transactional
    public Box addItemToBox(Long itemId, Long boxId) {
        Item item = itemRepository.findById(itemId)
                .orElseThrow(() -> new IllegalArgumentException("Item not found: " + itemId));
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new IllegalArgumentException("Box not found: " + boxId));

        // Enforce QC status match rule
        if (item.getQcStatus() != box.getQcStatus()) {
            throw new IllegalArgumentException(
                String.format("QC mismatch: Item QC %s cannot be added to Box QC %s",
                    item.getQcStatus(), box.getQcStatus()));
        }

        // Item status state machine: CREATED -> INWARD when added to INWARD Box
        if (box.getType() == StorageAreaType.INWARD) {
            item.setItemStatus(ItemStatus.INWARD);
        }

        // Add bidirectionally to sets (populates box_item mapping table)
        box.getItems().add(item);
        item.getBoxes().add(box);

        // Save owning side (Box) -- cascades status to Item
        return boxRepository.save(box);
    }
}