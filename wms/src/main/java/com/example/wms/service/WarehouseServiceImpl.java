package com.example.wms.service;

import com.example.wms.model.Aisle;
import com.example.wms.model.Box;
import com.example.wms.model.Item;
import com.example.wms.model.ItemStatus;
import com.example.wms.model.Location;
import com.example.wms.model.LocationCapacityType;
import com.example.wms.model.QcStatus;
import com.example.wms.model.StorageArea;
import com.example.wms.model.StorageAreaType;
import com.example.wms.repository.AisleRepository;
import com.example.wms.repository.BoxRepository;
import com.example.wms.repository.ItemRepository;
import com.example.wms.repository.LocationRepository;
import com.example.wms.repository.StorageAreaRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Implementation of WarehouseService with ID generation logic for hierarchical
 * storage locations in warehouse:
 * - StorageArea: auto-increment ID (type required:
 * INWARD/OUTWARD/STORAGE/PIGEON_HOLE)
 * - Aisle: S{areaId}-A{N} where N = count in area + 1
 * - Location: {aisleId}-L{M} where M = count in aisle + 1 (type: SINGLE/MULTI)
 * - Box: auto ID, type=StorageAreaType, nullable Location ref (type must match
 * on assignment)
 */
@Service
public class WarehouseServiceImpl implements WarehouseService {

    private final StorageAreaRepository storageAreaRepository;
    private final AisleRepository aisleRepository;
    private final LocationRepository locationRepository;
    private final BoxRepository boxRepository;
    private final ItemRepository itemRepository;

    public WarehouseServiceImpl(StorageAreaRepository storageAreaRepository,
            AisleRepository aisleRepository,
            LocationRepository locationRepository,
            BoxRepository boxRepository,
            ItemRepository itemRepository) {
        this.storageAreaRepository = storageAreaRepository;
        this.aisleRepository = aisleRepository;
        this.locationRepository = locationRepository;
        this.boxRepository = boxRepository;
        this.itemRepository = itemRepository;
    }

    @Override
    @Transactional
    public StorageArea createStorageArea(String description, StorageAreaType type) {
        if (type == null) {
            throw new IllegalArgumentException("StorageArea type is required");
        }
        // ID auto-generated by JPA
        StorageArea area = new StorageArea(description, type);
        return storageAreaRepository.save(area);
    }

    @Override
    @Transactional
    public Aisle createAisle(Long storageAreaId) {
        // Validate storage area exists
        if (!storageAreaRepository.existsById(storageAreaId)) {
            throw new IllegalArgumentException("Storage area not found: " + storageAreaId);
        }
        // Determine next aisle number in this storage area
        long aisleNum = aisleRepository.countByStorageAreaId(storageAreaId) + 1;
        String aisleId = "S" + storageAreaId + "-A" + aisleNum;
        // Check uniqueness (though sequential should ensure)
        if (aisleRepository.existsById(aisleId)) {
            throw new IllegalArgumentException("Aisle already exists: " + aisleId);
        }
        Aisle aisle = new Aisle(aisleId, storageAreaId);
        return aisleRepository.save(aisle);
    }

    @Override
    @Transactional
    public Location createLocation(Long storageAreaId, String aisleId, LocationCapacityType type) {
        if (type == null) {
            throw new IllegalArgumentException("Location type is required");
        }
        // Validate storage area and aisle exist
        if (!storageAreaRepository.existsById(storageAreaId)) {
            throw new IllegalArgumentException("Storage area not found: " + storageAreaId);
        }
        if (!aisleRepository.existsById(aisleId)) {
            throw new IllegalArgumentException("Aisle not found: " + aisleId);
        }
        // Determine next location number in this aisle
        long locNum = locationRepository.countByAisleId(aisleId) + 1;
        String locationId = aisleId + "-L" + locNum;
        // Check uniqueness
        if (locationRepository.existsById(locationId)) {
            throw new IllegalArgumentException("Location already exists: " + locationId);
        }
        Location location = new Location(locationId, storageAreaId, aisleId, type);
        return locationRepository.save(location);
    }

    @Override
    @Transactional
    public Box createBox(StorageAreaType type, QcStatus qcStatus, Long orderId) {
        if (type == null) {
            throw new IllegalArgumentException("Box type is required");
        }
        if (qcStatus == null) {
            throw new IllegalArgumentException("Box QC status is required");
        }
        if (type == StorageAreaType.INWARD && (orderId == null || orderId <= 0)) {
            throw new IllegalArgumentException("orderId required for INWARD box type");
        }
        // ID auto-generated; location/items nullable; orderId set for INWARD
        // (full OMS order validation in WMS layer)
        Box box = new Box(type, qcStatus);
        if (orderId != null) {
            box.setOrderId(orderId);
        }
        return boxRepository.save(box);
    }

    @Override
    @Transactional
    public Box updateBoxLocation(Long boxId, String locationId) {
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new IllegalArgumentException("Box not found: " + boxId));

        if (locationId == null || locationId.isEmpty()) {
            // Allow unassign
            box.setLocation(null);
            return boxRepository.save(box);
        }

        // Validate location exists
        Location location = locationRepository.findById(locationId)
                .orElseThrow(() -> new IllegalArgumentException("Location not found: " + locationId));

        // Enforce StorageArea type via area for new location
        Long areaId = location.getStorageAreaId();
        StorageArea area = storageAreaRepository.findById(areaId)
                .orElseThrow(() -> new IllegalArgumentException("Storage area not found for location"));

        // Guardrail for inventory accuracy: Box StorageAreaType movement state machine
        StorageAreaType newType = area.getType();
        StorageAreaType currentType = (box.getLocation() != null)
                ? getAreaTypeForLocation(box.getLocation())
                : null; // initial assignment allowed
        if (!isValidAreaTypeTransition(currentType, newType)) {
            throw new IllegalArgumentException(
                    String.format(
                            "Invalid state machine transition for Box %s: %s -> %s (allowed: INWARD->STORAGE, STORAGE<->STORAGE/OUTWARD, OUTWARD terminal)",
                            boxId, currentType, newType));
        }

        // Item/Box status state machine guardrail
        box.setStatus(newType); // sync Box status to new area type
        if (newType == StorageAreaType.STORAGE) {
            for (Item item : box.getItems()) {
                item.setItemStatus(ItemStatus.LIVE);
            }
        }

        box.setLocation(location);
        return boxRepository.save(box);
    }

    /**
     * Helper: Get StorageAreaType for a Location (via parent area) for state
     * machine checks.
     */
    private StorageAreaType getAreaTypeForLocation(Location location) {
        Long areaId = location.getStorageAreaId();
        return storageAreaRepository.findById(areaId)
                .orElseThrow(() -> new IllegalArgumentException("Storage area not found for location"))
                .getType();
    }

    /**
     * State machine guardrail for Box StorageAreaType movements to ensure inventory
     * accuracy.
     */
    private boolean isValidAreaTypeTransition(StorageAreaType current, StorageAreaType next) {
        if (current == null) {
            return true; // initial assignment
        }
        return switch (current) {
            case INWARD -> next == StorageAreaType.STORAGE;
            case STORAGE, PIGEON_HOLE -> next == StorageAreaType.STORAGE || next == StorageAreaType.OUTWARD;
            case OUTWARD -> false; // terminal, no moves
            default -> false;
        };
    }

    @Override
    @Transactional
    public Item createItem(String productId, QcStatus qcStatus) {
        if (qcStatus == null) {
            throw new IllegalArgumentException("Item QC status is required");
        }
        // Product validation delegated to WMS controller (calls OMS API)
        Item item = new Item(productId, qcStatus);
        return itemRepository.save(item);
    }

    @Override
    @Transactional
    public Box addItemToBox(Long itemId, Long boxId) {
        Item item = itemRepository.findById(itemId)
                .orElseThrow(() -> new IllegalArgumentException("Item not found: " + itemId));
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new IllegalArgumentException("Box not found: " + boxId));

        // Enforce QC status match rule
        if (item.getQcStatus() != box.getQcStatus()) {
            throw new IllegalArgumentException(
                    String.format("QC mismatch: Item QC %s cannot be added to Box QC %s",
                            item.getQcStatus(), box.getQcStatus()));
        }

        // Item status state machine: CREATED -> INWARD when added to INWARD Box
        if (box.getType() == StorageAreaType.INWARD) {
            item.setItemStatus(ItemStatus.INWARD);
        }

        // Add bidirectionally to sets (populates box_item mapping table)
        box.getItems().add(item);
        item.getBoxes().add(box);

        // Save owning side (Box) -- cascades status to Item
        return boxRepository.save(box);
    }
}
